\specialsection{Введение}

Современные микросервисные системы состоят из десятков и даже сотен компонентов, каждый из которых решает узкоспециализированную задачу и взаимодействует с другими через чётко определённые интерфейсы \cite{msa-overview}. Такой архитектурный подход обеспечивает масштабируемость, отказоустойчивость и модульность, однако одновременно с этим он порождает значительные сложности. В частности, становится всё труднее поддерживать целостность системы и соблюдать архитектурные решения, принятые на этапе проектирования. В отличие от ошибок в программной логике, архитектурные нарушения, как правило, не приводят к немедленным сбоям, но накапливаются в виде технического долга. Это снижает сопровождаемость системы, тормозит развитие и в перспективе ведёт к ухудшению качества продукта \cite{arch-debt}.

Процесс проектирования архитектуры включает в себя множество артефактов: диаграммы зависимостей, схемы взаимодействия, текстовые описания и негласные договорённости между командами. Эти материалы описывают желаемую структуру системы, однако со временем неизбежно устаревают и перестают отражать её фактическое состояние. При этом визуальные схемы или текстовые спецификации по своей природе носят декларативный характер — они позволяют понять, как компоненты связаны в идеале, но не дают ответа на вопрос, какие связи действительно реализованы в коде или конфигурациях. Например, архитектор может задать, что все интеграции с внешним сервисом должны проходить через слой Anti-Corruption Layer (ACL) \cite{acl-pattern}, однако у него нет надёжного способа проконтролировать соблюдение этого правила. Через некоторое время в систему может быть добавлена прямая зависимость от внешнего сервиса, нарушающая принцип изоляции, — и это останется незамеченным.

Подобные сценарии подчёркивают ключевую проблему: наличие формальных архитектурных принципов не гарантирует их соблюдение на практике. Архитектору сложно контролировать реализацию даже собственных решений, особенно когда архитектурные нарушения не приводят к очевидным ошибкам на уровне бизнес-логики. Ещё сложнее — количественно оценить архитектурный техдолг проекта. Между тем, эта метрика может быть крайне важной как для архитекторов, так и для разработчиков. Например, если в системе насчитывается пять случаев совместного доступа нескольких сервисов к одной и той же базе данных (антипаттерн shared-database \cite{antipatterns-taxonomy}), это является объективным показателем архитектурных нарушений. После проведения рефакторинга и устранения части таких связей можно говорить об <<измеримом>> улучшении архитектуры, опираясь на описанную метрику. Рост этой метрики, напротив, может сигнализировать о нарастающей деградации архитектуры, даже если это пока не отражается на функциональности приложения.

Один из подходов, частично решающий проблему документирования и контроля архитектуры, — это инфраструктура как код (Infrastructure-as-Code, IaC \cite{iac-concept}). В рамках него сервисы, базы данных и другие элементы окружения описываются в виде конфигураций, хранимых в системах контроля версий и проходящих те же процедуры ревью, что и программный код. Это позволяет воспроизводимо разворачивать окружение, отслеживать изменения и минимизировать влияние человеческого фактора. Более того, IaC обеспечивает явную связь между кодом и его инфраструктурным контекстом, снижая риск несогласованности. Однако даже в условиях, когда всё окружение формально описано, смысл архитектурных решений и бизнес-ограничений по-прежнему анализируется вручную.

Существующие инструменты, такие как ArchUnit, SonarGraph и некоторые другие, в определённой степени предоставляют поддержку автоматизированной валидации архитектурных ограничений. Они позволяют описывать правила с помощью собственных DSL-языков и применять проверки на соответствие этим правилам \cite{dsl-fowler}. Однако на практике эти решения нередко оказываются слишком ограниченными или сложными в интеграции. Высокий порог входа, необходимость точной настройки и ограниченная выразительность часто делают их неудобными для использования во времена быстрой эволюции микросервисных систем — особенно при наличии особенностей окружения, специфичных для конкретной организации. Более того, подавляющее большинство этих инструментов не предоставляют агрегированного представления архитектурного состояния, не поддерживают визуализацию отклонений и почти не используют числовые метрики, которые могли бы помочь в анализе архитектурного долга и его динамики во времени.

Таким образом, существует потребность в инструменте, который бы позволял явно описывать архитектурные принципы системы и проверять их соблюдение автоматически. При этом важно, чтобы такой инструмент был удобен для использования в процессе разработки: позволял быстро формулировать правила любой сложности, удобно запускался и органично интегрировался в инфраструктуру компании.

Данная работа направлена на анализ обозначенной проблемы и разработку подхода, позволяющего автоматически выявлять архитектурные антипаттерны в микросервисных системах. Основной акцент делается на практическую применимость, гибкость расширения набора проверок и удобство использования инструмента в рамках жизненного цикла разработки. Результатом станет прототип системы, способной на основе инфраструктурных конфигураций и связей между сервисами выявлять потенциальные архитектурные нарушения и тем самым способствовать контролю качества архитектуры в условиях её неизбежной эволюции.

Практическая реализация и апробация предлагаемого в данной работе инструмента будут проводиться в инфраструктуре Яндекс.Вертикалей. Это означает, что разрабатываемое решение будет изначально ориентировано на интеграцию с существующими в компании системами управления конфигурациями и развертывания. Такой подход позволит проверить инструмент на реальных задачах и сфокусироваться на решении архитектурных проблем, наиболее актуальных для компании, с учетом специфики технологического стека.
