\section{Внутреннее устройство библиотеки написания тестов}

В данном разделе будет рассмотрено внутреннее устройство библиотеки для написания архитектурных тестов. Библиотека предоставляет разработчикам высокоуровневое API, абстрагируя их от деталей парсинга конфигурационных файлов и представления архитектуры. Центральное место в этом API занимают методы объекта \verb|Service|, позволяющие проверять наличие зависимостей. Далее будут подробно описаны основные концепции, компоненты и алгоритмы, лежащие в основе этого механизма. 

\subsection{Основные подходы к написанию тестов}

Как было показано в разделе \ref{unit-tests-design}, написание архитектурных тестов сводится к вызову методов на экземплярах класса \verb|Service|
\begin{itemize}
    \item \verb|hasDependencyOn(service: Service): Boolean|
    \item \verb|hasDependencyOn(service: ServicePattern): Boolean|
    \item и так далее
\end{itemize}

\begin{code}{scala}
val serviceA = Services.service("service-a")
val serviceB = Services.service("service-b")
serviceA.hasDependencyOn(serviceB) shouldBe true

val ordersCom = ServicePattern.withHost("orders.com")
serviceA.hasDependencyOn(ordersCom) shouldBe false
\end{code}

Эти методы инкапсулируют логику поиска зависимостей как в явно декларированной секции \verb|depends_on| в карте сервиса, так и в переменных окружения, указанных в манифесте деплоя. Внутренний механизм, обеспечивающий эту функциональность, основан на гибкой системе сопоставления (matching), реализованной с помощью трейта \verb|Matchable|.

\subsection{Механизм сопоставления зависимостей}

\verb|Matchable[A, B]| определяет единственный метод \verb|matches(a, b)|, который возвращает \verb|true|, если объект \verb|a| типа \verb|A| <<соответствует>> объекту \verb|b| типа \verb|B| по некоторым критериям.

\begin{code}{scala}
trait Matchable[A, B] {
  def matches(a: A, b: B): Boolean
}
\end{code}

Такой подход позволяет абстрагироваться от конкретных способов сравнения сервисов или их атрибутов, предоставляя возможность легко подменять и комбинировать различные стратегии сопоставления.

\subsubsection{Поиск зависимости в секции depends\_on}

Для проверки, содержится ли сервис \verb|other| в списке явных зависимостей \verb|depend_on|, используется метод \verb|hasDependencyInServiceMap|. Он пробегается по списку зависимостей сервиса и пытается найти среди них совпадение с переданным \verb|other|.

Например, сервис, объявленный в коде как

\begin{codenl}{scala}
val serviceA = ServicePattern
  .withName("serviceA")
  .withInterfaceName("grpc-api")
\end{codenl}

должен <<соответствовать>> следующей записи в карте сервисов:

\begin{nocode}
depends_on:
  - service: service-a
    interface_name: grpc-api
\end{nocode}

При парсинге YAML-файла, эта запись преобразуется в экземпляр \verb|ServicePattern|. Таким образом, задача сводится к сопоставлению двух \verb|ServicePattern|: \verb|other| и полученного из списка \verb|dependsOn|. А это равносильно написанию \verb|Matchable[ServicePattern, ServicePattern]|.

Библиотека предоставляет экземпляр такого \verb|Matchable| по умолчанию. Он сравнивает сервисы по имени, типу и интерфейсам. Тем не менее, при необходимости пользователь может определить и передать в функцию свой собственный экземпляр \verb|Matchable|.

\subsubsection{Поиск зависимости в конфигурационных файлах}

Аналогичный подход используется для поиска зависимостей, косвенно определённых через переменные окружения в конфигурационных файлах сервиса.

Например, сервис:

\begin{codenl}{scala}
val serviceA = ServicePattern
  .withName("serviceB")
  .withInterfaceName("http-api")
\end{codenl}

может быть упомянут в конфигурации другого сервиса через различные переменные окружения: 

\begin{nocode}
SERVICE_B_HOST: ${host:service-b:http-api}
SERVICE_B_URL: service-b-http-api.yandex.net
\end{nocode}

Для обнаружения подобных неявных зависимостей достаточно пробежаться по списку переменных окружения сервиса с экземпляром \verb|Matchable| для \verb|ServicePattern| и \verb|EnvVariable|, где \verb|EnvVariable| — это простая структура, представляющая пару ключ-значение переменной окружения.

Аналогично поиску в depends\_on, библиотека предоставляет экземпляр нужного \verb|Matchable| по умолчанию. Он способен распознавать различные форматы указания зависимостей: URL, внутренние шаблоны Shiva, строки подключения к базам данных, указания на топики Kafka и многое другое.

\subsubsection{Гибкость и композируемость Matchable}

Ключевое преимущество трейта \verb|Matchable| заключается в его гибкости и возможности композиции. Поскольку типы \verb|A| и \verb|B| не зафиксированы, можно создавать экземпляры \verb|Matchable| для совершенно разных пар типов и комбинировать их для построения сложной логики сопоставления.

Существует два подхода к созданию экземпляров \verb|Matchable|. Более прямолинейный подход заключается в том, что можно определить экземпляр \verb|Matchable| как обычную функцию. Например, для сопоставления двух сервисов по их IP-адресам, можно написать следующее:

\begin{code}{scala}
val matchServicesByIp: Matchable1[ServicePattern] =
  (a: ServicePattern, b: ServicePattern) =>
    (a.ip, b.ip) match {
      case (Some(ipA), Some(ipB)) => ipA == ipB
      case _ => false
    }
\end{code}

Здесь и далее тип \verb|type Matchable1[A] = Matchable[A, A]| определен для удобства. 

С прямолинейным подходом получилось не сложнее, чем определить обычную функцию. Правда, переиспользовать такой код вряд ли получится. 

Второй подход отличается от первого и активно использует композицию. Библиотека предоставляет набор функций-конструкторов и комбинаторов, позволяющих собирать сложные \verb|Matchable| из более простых «строительных блоков».

\begin{itemize}
    \item \verb|byEquals[A]|: Создает \verb|Matchable1[A]|, который проверяет равенство переданных значений.    

\begin{codenl}{scala}
def byEquals[A]: Matchable1[A] =
  (a1: A, a2: A) => a1 == a2
\end{codenl}

    \item \verb|lift[A, B, C, D]|: <<Поднимает>> \verb|Matchable[A, B]| до \verb|Matchable[C, D]|, если есть способы преобразовать \verb|C| в \verb|A| и \verb|D| в \verb|B|.

\begin{codenl}{scala}
def lift[A, B, C, D](
    m: Matchable[A, B]
  )(ca: C => A, 
    db: D => B): Matchable[C, D] = 
  m.matches(ca(c), db(d))
\end{codenl}

    \item \verb|lift1[A, C]|: Сокращенная версия \verb|lift[A, B, C, D]| для случая, когда \verb|A == B| и \verb|C == D|.

\begin{codenl}{scala}
def lift1[A, C](
    m: Matchable1[A]
  )(ca: C => A): Matchable1[C] =
  lift[A, A, C, C](m)(ca, ca)
\end{codenl}

    \item \verb|options[A, B]|: Преобразует \verb|Matchable[A, B]| в версию с \verb|Option|. Сопоставление происходит, только если оба \verb|Option| содержат значения.

\begin{codenl}{scala}
def options[A, B](
    m: Matchable[A, B]
  ): Matchable[Option[A], Option[B]] = {
  case (Some(a), Some(b)) => m.matches(a, b)
  case _ => false
}
\end{codenl}

\end{itemize}

Используя эти конструкторы, пример \verb|matchServicesByIp| можно переписать по-другому.

\begin{code}{scala}
val matchStrings: Matchable1[String] = 
  byEquals[String]

val matchIps: Matchable1[Ip] =
  matchStrings.lift1[Ip](_.value)

val matchServicesByIp: Matchable1[ServicePattern] =
  matchIps.options.lift1[ServicePattern](_.ip)
\end{code}

Для улучшения читаемости кода, объявления стандартных функций вроде \verb|lift1| или \verb|options| продублированы в implicit-классах, что позволяет использовать их через точечную нотацию: \verb|matchIps.options.lift1(_.ip)|. Такой подход, хоть и кажется более многословным для простого случая, обеспечивает высокую степень переиспользования промежуточных \verb|Matchable|.

Библиотека также определяет функции \verb|or| и \verb|and| для комбинации нескольких \verb|Matchable|.

\begin{codenl}{scala}
def or[A, B](inners: Matchable[A, B]*): Matchable[A, B] =
  (a: A, b: B) => inners.exists(_.matches(a, b))

def and[A, B](inners: Matchable[A, B]*): Matchable[A, B] =
  (a: A, b: B) => inners.forall(_.matches(a, b))
\end{codenl}

Это позволяет выражать сложные условия сопоставления очень компактно. Например, стандартный \verb|Matchable1[ServicePattern]|, который используется по умолчанию, определен в библиотеке следующим образом.

\begin{code}{scala}
val byIp: Matchable1[ServicePattern] = 
  matchIps.options.lift1[ServicePattern](_.ip)

// byHost, byFqn, byInterfaces аналогично byIps

val matchServices: Matchable1[ServicePattern] =
  byIp or byHost or (byFqn and byInterfaces)
\end{code}

То есть сервисы считаются совпадающими, если у них совпадает IP-адрес, или хост, или одновременно полное имя сервиса и его интерфейсы.

\subsection{Прямой доступ к конфигурационным данным}

Хотя использование \verb|Matchable| является предпочтительным и наиболее гибким способом определения критериев сопоставления, иногда может потребоваться прямой доступ к сырым данным конфигурации. Библиотека оставляет такую возможность, предоставляя доступ к списку всех переменных окружения сервиса через поле \verb|config.all: Seq[EnvVariable]|.

Это может быть полезно для написания специфических проверок, которые сложно или нецелесообразно выражать через \verb|Matchable|. Таким образом разработчик тестов не ограничен предопределенными механизмами \verb|Matchable| и может реализовывать любую необходимую логику.

Рассмотрим пример теста, который проверяет, что у сервиса \verb|api-gateway| нет внешних зависимостей.

\begin{code}{scala}
"api-gateway" should "not have external dependencies" in {
  val apiGateway = Services.service("api-gateway")
  val envVariables = apiGateway.config.all
  envVariables.count(isExternalService) shouldBe 0
}
\end{code}

Тест использует функцию \verb|isExternalService|, которая по значению переменной окружения определяет, внешняя это зависимость или нет. Конкретная реализация функции опущена для краткости.

\subsection{Оптимизации для повышения производительности}

При анализе больших архитектур с сотнями сервисов и тысячами конфигурационных параметров производительность проверок становится важным фактором. В библиотеке реализовано несколько оптимизаций для ускорения процесса сопоставления зависимостей.

\subsubsection{Кеширование результатов сопоставления}

Тесты могут быть написаны таким образом, что одна и та же пара сервисов будет проверяться на наличие зависимости между ними несколько раз. В таком случае логично кешировать результаты сопоставления внутри экземпляра класса \verb|Service|, чтобы не вычислять их каждый раз заново.

При вызове методов типа \verb|hasDependencyOn| результат сначала ищется в соответствующем кеше. Если для данного аргумента \verb|ServicePattern| результат уже был вычислен ранее, он возвращается немедленно. В противном случае, выполняется честное сопоставление, и результат сохраняется в кеш для последующих вызовов. 
% Более формально это продемонстрировано в алгоритме \ref{has-dependency-on-cached}.

% \begin{algorithm}[hbt!]
% \caption{Проверка зависимости от другого сервиса c кешированием}\label{has-dependency-on-cached}

% \SetKwProg{hasDependencyOn}{hasDependencyOn}{}{}
% \hasDependencyOn{$(this, other, cache)$}{
% \KwData{$this$ — текущий сервис со своими зависимостями}
% \KwData{$other$ — другой сервис для проверки}
% \KwData{$cache$ — кеш с результатами предыдещих вызовов}

% \If{$other \notin cache$}{
%     $cache[other] \gets hasDependencyOn(this, other)$\;
% }

% \Return $cache[other]$\; 
% }
% \end{algorithm}

Оптимизация валидна, так как граф зависимостей не может поменяться во время выполнения тестов. При этом она срабатывает только при передаче стандартных экземпляров \verb|Matchable|, так как от конкретной реализации трейта зависит результат выполнения функции.

Кеширование обладает небольшими накладными расходами, но зато значительно сокращает количество повторных вычислений, особенно в сценариях с большим количеством тестов.

\subsubsection{Эвристики для ускорения сопоставления}

Наиболее дорогостоящая операция при выполнении тестов — это поиск зависимостей в конфигурационных файлах, так как он требует итерации по всем переменным окружения и применения к ним потенциально сложных правил \verb|Matchable|. Для ускорения этого и других процессов в библиотеке реализован ряд эвристик и подходов.

Во-первых, это эвристика \verb|skimConfig|, которая применяется перед полным сканированием конфигурации на наличие зависимости от сервиса \verb|other|. Если \verb|other| определён только по своему имени (что верно для большинства сервисов), метод быстро проверяет, содержится ли строка с именем этого сервиса в конкатенированном значении всех переменных окружения. Если имя не найдено, то детальное сопоставление с помощью \verb|Matchable| можно пропустить, так как зависимость по имени точно отсутствует. Эвристика не влияет на корректность результатов, так как используется только тогда, когда ее вывод является гарантированно верным. Эффективность данной схемы обусловлена тем фактом, что граф зависимостей скорее всего будет разреженным, то есть функция \verb|hasDependencyOn| гораздо чаще будет возвращать \verb|false|, чем \verb|true|. При этом поиск подстроки в строке выполняется гораздо быстрее честного сопоставления. В итоге, общий выигрыш в производительности достигается за счет того, что быстрое исключение большинства \verb|false|-случаев легко компенсирует незначительные накладные расходы на выполнение этой предварительной проверки в более редких \verb|true|-случаях.

Во-вторых, для выполнения массовых операций над всеми сервисами системы, таких как фильтрация или поиск, библиотека предоставляет параллельную коллекцию \verb|servicesPar: ParSeq[Service]|, использование которой в тестах позволяет задействовать многопоточность. Стоит отметить, что не всегда замена \verb|services| на \verb|servicesPar| даёт выигрыш, однако грамотное её использование также повышает производительность.

В-третьих, повсеместно применяется стратегия <<дешевых предварительных проверок>> перед выполнением дорогих операций. Например, известно, что любой внутренний шаблон Shiva для задания хоста сервиса начинается со знака \verb|'$'|. Поэтому перед применением сложного регулярного выражения, которое бы распарсило шаблон, сначала выполняется простая проверка, что первый символ строки является \verb|'$'|. Если нет, то применение регулярного выражения не производится, что немного ускоряет выполнение.

Эти основные оптимизации, вместе с другими, менее значительными улучшениями, позволили ускорить выполнение набора архитектурных тестов более чем в полтора раза. Если также учитывать выигрыш и от кеширования результатов сопоставления, то общая скорость выполнения тестов увеличилась почти в 2.5 раза по сравнению с вариантом без оптимизаций. Важно подчеркнуть, что точное измерение производительности не входило в задачи данной работы, поэтому приведённые значения являются оценочными и могут отличаться для разных наборов тестов и конфигураций оборудования. Тем не менее, можно утверждать, что после оптимизаций процесс анализа архитектуры заметно ускорился.
