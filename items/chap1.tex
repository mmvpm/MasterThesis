\section{Обзор предметной области}

Одним из ключевых аспектов, влияющих на долгосрочную жизнеспособность и эффективность микросервисных систем, является качество их архитектуры. Принятые на этапе проектирования решения определяют, насколько система будет гибкой, масштабируемой, отказоустойчивой и простой в сопровождении. Однако, как было отмечено во введении, существует значительный разрыв между декларируемыми архитектурными принципами и их фактической реализацией. Этот разрыв часто приводит к появлению так называемых архитектурных антипаттернов.

\subsection{Архитектурные антипаттерны}

Архитектурные антипаттерны — это неэффективные или неудачные решения повторяющихся проблем проектирования программных систем. Подобно тому, как <<паттерны проектирования>> предлагают проверенные временем решения для типичных задач \cite{microservices-patterns}, антипаттерны описывают распространённые ошибки и <<ловушки>>, в которые легко попасть при разработке. Возникновение антипаттернов часто является следствием неполного понимания проблемы, ограниченности ресурсов, давления сроков, недостаточной коммуникации между командами или постепенной эрозии первоначального замысла под влиянием изменений и доработок. Антипаттерны могут приводить к увеличению сложности, снижению производительности железа или к затруднению дальнейшего развития системы \cite{antipattern-def}.

Для более глубокого понимания проблемы рассмотрим буквально два известных примера архитектурных антипаттернов.

\subsubsection{Shared Database}

Одним из наиболее известных и часто встречаемых антипаттернов в микросервисных системах является <<Общая база данных>> (Shared Database \cite{shared-db-ap}). Он возникает, когда несколько независимых микросервисов напрямую обращаются к одной и той же физической базе данных, используя общие таблицы или даже всю схему данных. На первый взгляд, такое решение может показаться удобным, особенно на ранних этапах разработки или при миграции от монолитной архитектуры, поскольку оно упрощает обмен данными и позволяет избежать дублирования. Однако в долгосрочной перспективе общая база данных становится источником множества проблем.

\begin{figure}[ht]
   \centering
   \includesvg[scale=1]{images/shared-database.drawio.svg}
   \caption{\label{shared-database} Пример антипаттерна Shared Database.}
\end{figure}

Во-первых, она создаёт сильную связанность между сервисами на уровне данных. Любое изменение схемы базы данных, инициированное одним сервисом (например, добавление нового поля, изменение типа данных или удаление таблицы), может немедленно повлиять на работоспособность других сервисов, использующих эту же схему. Это приводит к тому, что команды разработки становятся зависимыми друг от друга, а процесс внесения изменений усложняется и требует тщательной координации, что противоречит идее автономности микросервисов.
Во-вторых, общая база данных затрудняет независимое масштабирование сервисов. Если один из сервисов создаёт высокую нагрузку на базу данных, это неизбежно скажется на производительности всех остальных сервисов, которые от неё зависят. База данных становится <<узким горлышком>> и единой точкой отказа для целой группы сервисов.
В-третьих, нарушается принцип инкапсуляции данных. Каждый микросервис должен владеть своими данными и предоставлять доступ к ним исключительно через чётко определённый API \cite{data-encapsulation-msa}. Прямой доступ к данным другого сервиса в обход его API нарушает этот принцип, делая систему более хрупкой и сложной для понимания.

% \subsubsection{God Service}

% Другим распространённым антипаттерном является <<Божественный сервис>> (God Service) или <<микромонолит>>. Этот антипаттерн характеризуется наличием сервиса, который аккумулируют слишком много разнородных функций и знаний о других частях системы. Такой сервис становится центральным узлом, через который проходит большинство взаимодействий, и он часто знает о деталях реализации других сервисов, с которыми интегрируется.
% Проблема микромонолита заключается в том, что он нарушает принцип единой ответственности и приводит к тем же недостаткам, которые присущи монолитным архитектурам, но теперь уже на уровне отдельного сервиса. Разработка и тестирование такого сервиса усложняются из-за его большого размера и множества зависимостей. Любые изменения в нём потенциально затрагивают значительную часть функциональности системы, что увеличивает риски при развёртывании. Масштабирование такого сервиса также становится неэффективным, поскольку приходится масштабировать все его функции целиком, даже если высокая нагрузка возникает только на одной из них. Более того, отказ <<божественного сервиса>> может привести к каскадному отказу значительной части системы, снижая её общую отказоустойчивость.
% Возникновение такого антипаттерна часто связано с постепенным разрастанием функциональности существующего сервиса, когда новые задачи добавляются в наиболее подходящий с точки зрения текущего контекста сервис, не задумываясь о долгосрочных архитектурных последствиях.

\subsubsection{Lava Flow}

Следующий пример антипаттерна, иллюстрирующий сложности поддержания архитектурной целостности, – это <<Поток лавы>> (Lava Flow \cite{lava-flow-ap}). Этот антипаттерн описывает ситуацию, когда в системе накапливаются устаревшие компоненты или код, которые никто не решается удалить из-за страха нарушить работоспособность системы. Оставаясь в системе, они затрудняют её понимание, сопровождение и развитие.
<<Поток лавы>> может проявляться в виде мёртвого кода, неиспользуемых конфигурационных параметров или даже целых сервисов и баз данных, которые когда-то были нужны, но со временем их функциональность была перенесена или стала ненужной. Проблема заключается в том, что наличие таких артефактов увеличивает когнитивную нагрузку на разработчиков и архитекторов. Приходится тратить время на анализ этих элементов, чтобы понять, нужны ли они ещё, и как они взаимодействуют (или не взаимодействуют) с остальной системой. Это замедляет разработку новых функций и увеличивает риск внесения ошибок.
Сложность борьбы с описанным антипаттерном заключается в отсутствии точной информации о реальном использовании тех или иных частей системы. Документация часто отстаёт от реального положения дел, а разработчики, которые изначально создавали эти компоненты, могли уже покинуть проект. В результате, решение об удалении чего-либо принимается с большой осторожностью, и часто проще оставить всё как есть, усугубляя проблему.

\subsection{Существующие инструменты}

Ключевая проблема, которую подчёркивают архитектурные антипаттерны, заключается в том, что их возникновение часто является постепенным и незаметным процессом. В больших, динамично развивающихся микросервисных системах архитектору чрезвычайно сложно отслеживать соблюдение всех заложенных принципов вручную. Архитектурные диаграммы и описания показывают желаемое состояние, но не гарантируют его реализацию. Эта ситуация породила спрос на инструменты, способные автоматически анализировать фактическую структуру системы и выявлять отклонения от заданных архитектурных правил. Рассмотрим некоторые из существующих подходов и инструментов.

\subsubsection{ArchUnit}

ArchUnit представляет собой бесплатную библиотеку с открытым исходным кодом для языка Java, предназначенную для проверки архитектурных правил непосредственно в коде \cite{archunit-site}. Она позволяет разработчикам писать модульные тесты, которые анализируют байт-код приложения и проверяют его на соответствие заданным ограничениям. Правила описываются с помощью гибкого и выразительного предметно-ориентированного языка (DSL).

Например, можно легко определить правило, запрещающее классам из доменного слоя (\verb|..domain..|) зависеть от классов слоя представления (\verb|..web..|), или более сложные правила, описывающие слоистую архитектуру и разрешённые зависимости между ними:

\begin{code}{java}
class ArchitectureTest {
    private final ClassFileImporter importer = 
            new ClassFileImporter();
    private final JavaClasses importedClasses =
            importer.importPackages("com.example");

    @Test
    void domainModelDoesNotDependOnUpperLayers() {
        ArchRule rule = noClasses()
                .that().resideInAPackage("..domain..")
                .should().dependOnClassesThat()
                .resideInAnyPackage("..web..");

        rule.check(importedClasses);
    }
}
\end{code}

Сильной стороной ArchUnit является его интеграция в процесс непрерывной интеграции (CI/CD), где архитектурные тесты выполняются наряду с другими автоматизированными тестами, предотвращая попадание нарушений в основную кодовую базу. Однако ArchUnit ориентирован исключительно на анализ архитектуры внутри одного Java-приложения (монолита или отдельного микросервиса), и не предназначен для анализа межсервисных взаимодействий.

\subsubsection{SonarGraph и Structure101}

Инструменты SonarGraph (часть коммерческой платформы SonarQube \cite{sonargraph-tool}) и Structure101 \cite{structure101-tool}, фокусируются на визуализации и анализе зависимостей на более высоком уровне абстракции – между модулями или компонентами системы.

SonarGraph позволяет архитекторам определять эталонную архитектуру, описывая компоненты системы и разрешённые зависимости между ними. Затем, в процессе анализа кода, SonarGraph сопоставляет фактические зависимости с этой моделью и сообщает о нарушениях. Например, архитектор может задать правило, что модуль \verb|ServiceA| не должен напрямую обращаться к модулю \verb|ServiceB|, а только через общий модуль \verb|CoreServices|. При обнаружении прямого вызова SonarGraph отметит это как нарушение. Инструмент интегрируется в SonarQube и помогает отслеживать соответствие архитектурным гайдлайнам в динамике.

Structure101 предоставляет средства для визуализации архитектуры. Он строит диаграммы зависимостей, которые помогают выявлять запутанные узлы системы, циклические зависимости и чрезмерно крупные компоненты. Structure101 использует метрики для количественной оценки степени нарушения архитектурных принципов (например, принципа единой ответственности на уровне компонентов). На основе этих данных разработчики могут анализировать архитектуру и принимать решения о рефакторинге. Однако никакой автоматизации в этом месте инструмент не предоставляет.

Эти инструменты полезны для получения общего представления об архитектуре. Однако их практическое применение может быть сопряжено с трудностями. Создание и поддержка актуальной архитектурной модели для сложной, быстро меняющейся микросервисной системы требует значительных усилий. Встроенные языки для описания правил могут оказаться недостаточно гибкими для формализации всех специфических требований проекта. Кроме того, основной фокус этих инструментов – анализ кода, и им может не хватать информации о связях, определённых на уровне инфраструктуры.

\subsubsection{Концепция тестов на архитектуру}

Наиболее близким по идеологии к задачам данной работы является подход, представленный в докладе <<Раз архитектура — "as Code"\text{,} почему бы её не покрыть тестами?!>> на конференции ArchDays 2023 \cite{archdays-talk-aac}.

Центральная идея этого подхода заключается в активном использовании артефактов, создаваемых в рамках практик <<Infrastructure-as-Code>> (IaC) и <<Architecture-as-Code>> (AaC). Если инфраструктура системы (сервисы, базы данных, сетевые настройки) описывается в виде кода (например, с помощью Terraform \cite{terraform}, Kubernetes manifests \cite{k8s-manifests}, Ansible \cite{ansible} и так далее), а архитектурные диаграммы и модели также хранятся в текстовом, машиночитаемом формате (PlantUML \cite{plantuml-tool}, Mermaid \cite{mermaid-tool}), то появляется возможность для их автоматического сопоставления и анализа. Примеры IaC-конфигурации и AaC-диаграмы приведены в листингах \ref{iac-example} и \ref{aac-example}.

\begin{listing}[ht]
\begin{codenl}{terraform}
    resource "docker_container" "service_b" {
      name  = "service-b"
      image = "myregistry/service-b:latest"
      ports {
        internal = 8081
        external = 8081
      }
      env = [
        "DATABASE_URL=postgresql://database-b:5432/mydb"
      ]
    }    
\end{codenl}
\caption{Пример простой Terraform-конфигурации.}
\label{iac-example}
\end{listing}

\begin{listing}[ht]
\begin{codenl}{text}
    @startuml C4ContainerDiagram
    
    Container_Boundary(boundary, "System") {
        Container(serviceA, "ServiceA")
        Container(serviceB, "ServiceB")
        ContainerDb(databaseB, "DatabaseB")
    }
    
    Rel(serviceA, serviceB, "Calls", "HTTP/REST")
    Rel(serviceB, databaseB, "Reads/Writes", "JDBC")
    
    @enduml
\end{codenl}
\caption{Пример PlantUML-диаграммы в формате C4 Model.}
\label{aac-example}
\end{listing}

Концепция <<Архитектура как тесты>> предлагает решать две фундаментальные проблемы, свойственные традиционному управлению архитектурой. Во-первых, это проблема устаревания архитектурной документации. В динамично развивающихся системах любые изменения в реальной конфигурации сервисов или их взаимодействий должны немедленно отражаться в архитектурных схемах. В противном случае документация быстро теряет свою актуальность и перестаёт быть надёжным источником информации. Предлагаемый подход позволяет автоматически сравнивать реальную конфигурацию, извлечённую из IaC-артефактов, с задокументированной архитектурой из AaC-источников. Любое расхождение выявляется при прогоне тестов в CI/CD пайплайне, сигнализируя о необходимости либо обновить документацию, либо откатить несогласованное изменение в инфраструктуре. Таким образом, обеспечивается синхронизация реального состояния системы с её описанием.

Во-вторых, решается проблема декларативности и неявности архитектурных ограничений в схемах. Сами по себе диаграммы часто показывают лишь существующие связи, но не отвечают на вопрос, какие связи запрещены или какие архитектурные принципы должны соблюдаться. Например, если на диаграмме \verb|ServiceA| не взаимодействует напрямую с базой данных сервиса \verb|ServiceB|, то неясно, можно ли в будущем добавить такую связь или нельзя. Архитектура в виде картинки об этом ничего не говорит (рис. \ref{declarative-example}).

\begin{figure}[ht]
   \centering
   \includesvg[scale=1]{images/declarative-example.drawio.svg}
   \caption{\label{declarative-example} Декларативность архитектурных диаграмм.}
\end{figure}

Подход <<Архитектура как тесты>> позволяет формализовать эти неявные правила и принципы в виде исполняемых тестов. Эти тесты оперируют графом зависимостей, построенным на основе архитектурных диаграмм AaC. Таким образом, становится возможным валидировать архитектурные решения, заложенные именно в этих диаграммах. Например, можно написать тест, проверяющий, что ни один сервис, кроме \verb|ServiceB|, не зависит от \verb|DatabaseB|, и этот тест будет выполняться на модели, извлечённой из PlantUML-описания.

Прототип инструмента, предлагаемый в рамках этой концепции, включает автоматический парсинг IaC-конфигураций для получения графа реальных связей и AaC-диаграмм для получения графа ожидаемых или эталонных связей. Далее, с помощью набора обычных unit-тестов, производится проверка различных свойств этих графов. Это могут быть тесты на полное соответствие двух графов, тесты на отсутствие определённых типов связей в реальной архитектуре, если они не разрешены в эталонной, или тесты, проверяющие соблюдение высокоуровневых архитектурных принципов.

Для лучшего понимания подхода рассмотрим пример теста, который проверяется, что только сервисы, помеченные тегом \verb|"acl"|, могут иметь зависимости от внешних систем:

\begin{code}{javascript}
it("only acl can depence from external systems", () => {
  let violationsCount = 0;

  for (const container of containersFromPuml) { 
    const isAcl = container.tags?.includes("acl");
    const externalRelations = container.relations.filter(
      (relation) => relation.to.type === ExternalType
    );
    
    if (!isAcl && externalRelations.length > 0) {
      violationsCount += externalRelations.length;
    }
  }

  expect(violationsCount).toBe(0); 
});
\end{code}

Интеграция таких тестов в CI/CD-конвейер позволяет превратить архитектурные принципы из деклараций в исполняемые спецификации. Любое изменение, нарушающее эти принципы или приводящее к рассинхронизации с документацией, будет автоматически обнаружено. Единственное серьёзное ограничение данного подхода — наличие внедренной в компании практики Architecture-as-Сode. Также важно отметить, что рассмотренный инструмент находится на стадии прототипа, то есть скорее демонстрирует интересную идею, чем предоставляет готовое к использованию решение.

\subsubsection{Выводы}

Проведённый обзор существующих решений для контроля архитектуры показывает, что многие из них имеют значительные недостатки или недоработки, препятствующие их практическому применению на реальных микросервисных системах. Так ArchUnit ориентирован на анализ кода только внутри одного сервиса. SonarGraph и Structure101 не предоставляют никакой автоматизации для проверки соблюдения принципов. Концепция <<Архитектура как тесты>> пока что находится на стадии прототипа, а также требует наличие в проекте архитектурных диаграмм в виде кода, что на самом деле является серьезным ограничением. Также стоит отметить, что все рассмотренные подходы требуют усилий по интеграции с корпоративными решениями, инструментами разработки и инфраструктурой.

\newpage

\subsection{Инфраструктура как код}

Концепция Infrastructure-as-Code (IaC) представляет собой подход к управлению и предоставлению вычислительной инфраструктуры (серверов, сетей, хранилищ, балансировщиков нагрузки, баз данных и других компонентов) через машиночитаемые файлы определений, а не посредством ручной настройки или интерактивных инструментов конфигурирования. Эти файлы, вместе с исходным кодом самих сервисов, хранятся в системе контроля версий, проходят через процессы ревью и автоматизированного развёртывания. Такой подход существенно упрощает внедрение и сопровождения IT-инфраструктуры, особенно в контексте облачных вычислений и микросервисных архитектур.

Основными принципами IaC являются автоматизация, воспроизводимость и идемпотентность \cite{iac-principles}. Автоматизация достигается за счёт использования специализированных инструментов, которые интерпретируют файлы определений и приводят инфраструктуру в желаемое состояние. Воспроизводимость означает, что одна и та же конфигурация, применённая в различных окружениях, будет создавать идентичные или предсказуемо схожие инфраструктурные ландшафты. Идемпотентность гарантирует, что повторное применение одной и той же конфигурации не приведёт к нежелательным изменениям, если система уже находится в целевом состоянии.

Существует множество инструментов, реализующих подход IaC: AWS CloudFormation, Terraform, Azure Resource Manager templates, Google Cloud Deployment Manager, Ansible, Puppet, Chef и многие другие. Эти инструменты позволяют описывать желаемое состояние инфраструктуры, используя либо декларативный (описание конечного результата), либо императивный (описание последовательности шагов для достижения результата) стиль. Например, в Terraform разработчик описывает ресурсы (виртуальные машины, базы данных, сетевые правила) и их взаимосвязи в текстовых файлах \verb|.tf|. Terraform затем вычисляет план действий для создания или изменения инфраструктуры до соответствия этому описанию. Аналогично, манифесты Kubernetes в формате YAML или JSON описывают развёртывания, сервисы, конфигурационные карты и другие сущности, необходимые для запуска приложений в контейнерах.

Таким образом, IaC-артефакты представляют собой формализованное и машиночитаемое описание инфраструктуры, где определяются структурные зависимости и связи между компонентами системы:

\begin{itemize}
    \item Определения взаимосвязей ресурсов. IaC-инструменты описывают не только сами компоненты, но и то, как они связаны. Например, Terraform-конфигурация может явно указывать, что определённый микросервис использует конкретный экземпляр базы данных, передавая его адрес через переменные окружения.
    \item Service Mesh. инструменты типа Istio или Linkerd, управляемые через IaC-манифесты, содержат детальные политики взаимодействия между сервисами \cite{istio-mesh}.
    \item Сетевые конфигурации. Правила файрволов, группы безопасности и так далее явно разрешают или запрещают коммуникацию между определёнными IP-адресами или группами ресурсов.
\end{itemize}

Анализ этих конфигурационных файлов позволяет построить граф реальных зависимостей системы. Этот граф отражает, как сервисы связаны друг с другом, какие общие ресурсы они используют, и какие коммуникационные пути между ними фактически настроены. Полученная модель может быть использована для анализа, направленного на выявление архитектурных антипаттернов. Правда, здесь необходимо отметить, что IaC не способен составить архитектурную модель верную на 100\%. В частности, динамические связи, устанавливаемые непосредственно в коде приложений во время выполнения, могут оставаться невидимыми. Однако такой подход сам по себе является в некотором роде <<антипаттерном>>, и обычно разработчики стараются выносить зависимости между сервисами на уровень конфигурации.

\subsection{Система деплоя Shiva}

В контексте разработки инструмента для автоматического обнаружения архитектурных антипаттернов в Яндекс.Вертикалях, ключевым источником информации о фактической структуре системы и связях между её компонентами выступает внутренняя система управления деплоями — Shiva. Shiva представляет собой инфраструктурный сервис, который абстрагирует разработчиков от деталей оркестрации контейнеров и механизмов service discovery, предоставляя унифицированный интерфейс для развёртывания и управления жизненным циклом микросервисов.

Центральным артефактом, с которым работает Shiva, является <<карта сервиса>> (service map). Это декларативное описание сервиса в формате YAML, содержащее всю необходимую метаинформацию. Карта сервиса включает в себя:

\begin{itemize}
    \item \verb|name|: Уникальное имя сервиса.
    \item \verb|type|: Тип компонента (например, \verb|service|).
    \item \verb|owners|: Список ответственных за сервис команд.
    \item \verb|provides|: Определяет интерфейсы, которые сервис предоставляет другим компонентам. Каждый такой интерфейс описывается именем, протоколом, портом и некоторыми другим опциональными параметрами.
    \item \verb|depends_on|: Список сервисов, от которых зависит данный компонент. Для каждой зависимости указывается имя целевого сервиса (\verb|service_name|) и имя используемого интерфейса (\verb|interface_name|). На данный момент секция не является обязательной, поэтому для большинства сервисов все их реальные зависимости не будут отражены в этом списке.
\end{itemize}

А также многие другие поля, менее важные в контексте составления графа зависимостей. Ниже приведен простейший пример карты сервиса в Shiva:

\begin{nocode}
name: service-a
type: service
provides:
- name: grpc-api
  protocol: grpc
  port: 80
depends_on:
- service_name: service-b
  interface_name: http-api
\end{nocode}

На основе карты сервиса Shiva подготавливает инфраструктуру для контейнеров, управляет их ресурсами и жизненным циклом. Процесс деплоя также конфигурируется декларативно с помощью манифеста деплоя, который является ещё одним YAML-файлом. Манифест деплоя определяет параметры развёртывания для различных окружений (prod и test), включая:

\begin{itemize}
    \item \verb|datacenters|: Количество инстансов сервиса в каждом дата-центре.
    \item \verb|resources|: Запросы к ресурсам (CPU, память).
    \item \verb|config|: Специфичные для окружения конфигурации в виде переменных окружения, которые будут установлены в контейнере.
\end{itemize}

А также некоторые другие поля. Для лучшего понимания ниже приведен пример части манифеста деплоя сервиса в Shiva:

\begin{nocode}
prod:
  resources:
    cpu: 1000
    memory: 3072
  config:
    params:
      - SERVICE_B_URL: service-b-grpc-api.yandex.net
      - DB_URL: jdbc:postgresql://...
      - DB_USER: ...
\end{nocode}


Для выявления актуальных зависимостей сервиса, помимо \verb|depends_on| в карте сервиса, нужно смотреть в переменные окружения, определяемые в манифесте деплоя. Именно через них сервисы часто получают информацию о местонахождении других сервисов или баз данных. Например, переменная \verb|SERVICE_B_URL: service-b-grpc-api.yandex.net| указывает, что данный сервис будет обращаться к сервису \verb|service-b| по его grpc-api интерфейсу. Аналогично, переменные вида \verb|DB_URL: jdbc:postgresql://...| явно указывают на используемые экземпляры баз данных.

Таким образом, карты сервисов и манифесты деплоя в системе Shiva представляют собой богатый источник структурированной информации об архитектуре системы. Анализируя эти артефакты, можно с высокой точностью восстановить граф зависимостей между микросервисами, а также их связи с базами данных и другими инфраструктурными компонентами. Именно эти данные и предполагается использовать в этой работе. 
